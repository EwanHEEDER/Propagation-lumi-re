import numpy as np

ds = 1 #km


def dérivée(i, v, u, s, n):
    
    # u est un tuple (r, dr/ds). /!\ r et dr/dt sont des vecteurs
    
    du = np.empty(np.shape(u))
    
    dn = n(v[i,0]) - n(v[i-1,0]) #Problème
    
    dx = v[i,0,0] - v[i-1, 0, 0] #Problème aussi
    
    grad_n = (dn/dx) * np.array([1,0]) # + (dn/dy) * np.array([0,1])
    
    #print("grad_n =", grad_n)
    
    du[0] = u[1]
    du[1] = grad_n - dn/ds * u[1]
    
    return du # une liste , (dr/ds, d^2(r) / ds^2)

def RK4(tot_trajec, step, v_ini, derive, n):

    # Création du tableau d'abscisse curviligne
    
    num_points = int(tot_trajec / step) + 1     # nombre d'éléments
    s = np.linspace(0, tot_trajec, num_points)    # tableau d'abscisse curviligne, on commence obligatoirement à 0

    # initialisation du tableau v, à 3 dimensions: Pour chaque pas --> deux vecteurs de dimension 2
    v = np.empty((num_points,2,2))
    


    # condition initiale
    v[0] = v_ini 

    # boucle for
    
    for i in range(1,num_points):
        print("i = ", i)
        
        print("x[i-1] = ", v[i-1,0,0])
        
        print("x[i] = ", v[i,0,0])
        
        print("dx = ",v[i,0,0] - v[i-1, 0, 0])
        
        
        
        
        #On change la fonction utilisée pour le calcul de dérivée
        
        d1 = np.array(derive(i-1,v,v[i-1], s[i-1], n))
        
        d2 = np.array(derive(i-1,v,v[i-1] + d1 * step/2, s[i-1] + step/2, n))
        
        d3 = np.array(derive(i-1,v,v[i-1] + d2 * step/2, s[i-1] + step/2, n))
        
        d4 = np.array(derive(i-1,v,v[i-1] + d3 * step, s[i-1] + step, n))
        
        v[i] = v[i-1] + (d1 + 2 * d2 + 2 * d3 + d4) * step / 6
        
        
   
    # argument de sortie
    return s , v
